// cmd: go run main.go -input map2.tmj -map-id main_world -chunk 16x16 -rev 1 -out out_sql
package main

import (
	"bytes"
	"compress/gzip"
	"encoding/hex"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"math"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"
)

/* ------------------- Tiled 基本数据结构（含需要的字段） ------------------- */

type TiledMap struct {
	CompressionLevel int               `json:"compressionlevel"`
	Infinite         bool              `json:"infinite"`
	Orientation      string            `json:"orientation"`
	RenderOrder      string            `json:"renderorder"`
	TiledVersion     string            `json:"tiledversion"`
	Type             string            `json:"type"`    // "map"
	Version          string            `json:"version"` // "1.10"
	Width            int               `json:"width"`
	Height           int               `json:"height"`
	TileWidth        int               `json:"tilewidth"`
	TileHeight       int               `json:"tileheight"`
	NextLayerID      int               `json:"nextlayerid"`
	NextObjectID     int               `json:"nextobjectid"`
	Layers           []Layer           `json:"layers"`
	Tilesets         []json.RawMessage `json:"tilesets"` // 原样透传
}

type Layer struct {
	ID      int     `json:"id"`
	Name    string  `json:"name"`
	Type    string  `json:"type"` // tilelayer | objectgroup | imagelayer ...
	Visible bool    `json:"visible"`
	Opacity float64 `json:"opacity"`
	// tilelayer
	Width  int   `json:"width"`
	Height int   `json:"height"`
	Data   []int `json:"data"`

	// imagelayer
	Image       string `json:"image"`
	ImageWidth  int    `json:"imagewidth"`
	ImageHeight int    `json:"imageheight"`
	RepeatX     bool   `json:"repeatx"`
	RepeatY     bool   `json:"repeaty"`
	X           int    `json:"x"`
	Y           int    `json:"y"`

	// objectgroup
	Objects []TiledObject `json:"objects"`

	Properties []TiledProp `json:"properties"`
}

type TiledObject struct {
	ID         int         `json:"id"`
	Name       string      `json:"name"`
	Type       string      `json:"type"`
	Gid        int         `json:"gid"`
	X          float64     `json:"x"`
	Y          float64     `json:"y"`
	Width      float64     `json:"width"`
	Height     float64     `json:"height"`
	Rotation   float64     `json:"rotation"`
	Visible    bool        `json:"visible"`
	Properties []TiledProp `json:"properties"`
}

type TiledProp struct {
	Name  string          `json:"name"`
	Type  string          `json:"type"`
	Value json.RawMessage `json:"value"`
}

/* ------------------- 入口 ------------------- */

func main() {
	input := flag.String("input", "map.tmj", "Path to Tiled JSON (.tmj/.json)")
	mapID := flag.String("map-id", "", "Map ID (default: derive from file name)")
	chunk := flag.String("chunk", "16x16", "Chunk size in tiles, e.g. 16x16 / 32x32")
	rev := flag.Int("rev", 1, "Chunk revision")
	outDir := flag.String("out", "out_sql", "Output directory")
	flag.Parse()

	chW, chH, err := parseChunk(*chunk)
	must(err)

	raw, err := os.ReadFile(*input)
	must(err)

	var tm TiledMap
	must(json.Unmarshal(raw, &tm))

	if *mapID == "" {
		*mapID = sanitizeMapID(strings.TrimSuffix(filepath.Base(*input), filepath.Ext(*input)))
	}

	gridW := int(math.Ceil(float64(tm.Width) / float64(chW)))
	gridH := int(math.Ceil(float64(tm.Height) / float64(chH)))

	_ = os.MkdirAll(*outDir, 0o755)

	// 输出文件
	fAll := mustCreate(filepath.Join(*outDir, "all.sql"))
	defer fAll.Close()
	fChunk := mustCreate(filepath.Join(*outDir, "map_chunk_layer_inserts.sql"))
	defer fChunk.Close()
	fEntity := mustCreate(filepath.Join(*outDir, "map_entity_inserts.sql"))
	defer fEntity.Close()
	fMeta := mustCreate(filepath.Join(*outDir, "map_meta_inserts.sql"))
	defer fMeta.Close()
	fImg := mustCreate(filepath.Join(*outDir, "map_imagelayer_inserts.sql"))
	defer fImg.Close()
	fLayerMeta := mustCreate(filepath.Join(*outDir, "map_layer_meta_inserts.sql"))
	defer fLayerMeta.Close()

	w := func(s string) { fAll.WriteString(s) } // 汇总
	w("-- Generated by map-slicer\n\nSET NAMES utf8mb4; SET FOREIGN_KEY_CHECKS=0;\n\n")

	/* -------- 1) map_meta：tmj 头信息 + tilesets -------- */

	header := map[string]any{
		"compressionlevel": tm.CompressionLevel,
		"infinite":         tm.Infinite,
		"orientation":      tm.Orientation,
		"renderorder":      tm.RenderOrder,
		"tiledversion":     tm.TiledVersion,
		"type":             tm.Type,
		"version":          tm.Version,
		"width":            tm.Width,
		"height":           tm.Height,
		"tilewidth":        tm.TileWidth,
		"tileheight":       tm.TileHeight,
		"nextlayerid":      tm.NextLayerID,
		"nextobjectid":     tm.NextObjectID,
	}
	headerJSON := toMinJSON(header)
	tilesetsJSON := toMinJSON(tm.Tilesets)

	sqlMeta := fmt.Sprintf(
		"REPLACE INTO map_meta (map_id, header_json, tilesets_json) VALUES ('%s','%s','%s');\n",
		escapeSQL(*mapID), escapeSQL(headerJSON), escapeSQL(tilesetsJSON),
	)
	fMeta.WriteString("-- map_meta\n" + sqlMeta + "\n")
	w(sqlMeta)

	/* -------- 2) map_imagelayer：保存 bg 等图像层 -------- */

	type imgRow struct {
		Name    string
		Z       int
		Image   string
		Opacity float64
		RX, RY  bool
		X, Y    int
		Vis     bool
	}
	var imgs []imgRow
	for _, l := range tm.Layers {
		if l.Type != "imagelayer" {
			continue
		}
		imgs = append(imgs, imgRow{
			Name: l.Name, Z: l.ID, Image: l.Image, Opacity: l.Opacity,
			RX: l.RepeatX, RY: l.RepeatY, X: l.X, Y: l.Y, Vis: l.Visible,
		})
	}
	sort.Slice(imgs, func(i, j int) bool { return imgs[i].Z < imgs[j].Z })

	if len(imgs) > 0 {
		fImg.WriteString("-- map_imagelayer\n")
		for _, r := range imgs {
			stmt := fmt.Sprintf(
				"REPLACE INTO map_imagelayer (map_id, name, z_index, image, opacity, repeatx, repeaty, x, y, visible) "+
					"VALUES ('%s','%s',%d,'%s',%g,%t,%t,%d,%d,%t);\n",
				escapeSQL(*mapID), escapeSQL(r.Name), r.Z,
				escapeSQL(r.Image), r.Opacity, r.RX, r.RY, r.X, r.Y, r.Vis,
			)
			fImg.WriteString(stmt)
			w(stmt)
		}
		w("\n")
	}

	/* -------- 3) map_layer_meta：给每个图层写元数据（z 顺序 & kind） -------- */

	fLayerMeta.WriteString("-- map_layer_meta\n")
	for _, l := range tm.Layers {
		kind := guessKind(l) // base/nature/business/path/deco/other
		stmt := fmt.Sprintf(
			"REPLACE INTO map_layer_meta (map_id, layer, z_index, kind, style) VALUES "+
				"('%s','%s',%d,'%s',NULL);\n",
			escapeSQL(*mapID), escapeSQL(l.Name), l.ID, kind,
		)
		fLayerMeta.WriteString(stmt)
		w(stmt)
	}
	w("\n")

	/* -------- 4) map_chunk_layer：切 tilelayer 入库 -------- */

	fChunk.WriteString(fmt.Sprintf("-- INSERTs for map_chunk_layer (map_id=%s, chunk=%dx%d, grid=%dx%d, tile=%dx%d px)\n",
		*mapID, chW, chH, gridW, gridH, tm.TileWidth, tm.TileHeight))
	for _, layer := range tm.Layers {
		if layer.Type != "tilelayer" {
			continue
		}
		lname := layer.Name
		if lname == "" {
			lname = fmt.Sprintf("layer_%d", layer.ID)
		}
		if layer.Width != tm.Width || layer.Height != tm.Height {
			fmt.Fprintf(os.Stderr, "warn: tilelayer %q size (%dx%d) != map size (%dx%d)\n",
				lname, layer.Width, layer.Height, tm.Width, tm.Height)
		}
		for cy := 0; cy < gridH; cy++ {
			for cx := 0; cx < gridW; cx++ {
				sx := cx * chW
				sy := cy * chH
				sub := extractTileChunk(layer.Data, tm.Width, tm.Height, sx, sy, chW, chH)
				payload := map[string]any{
					"mapId":      *mapID,
					"layer":      lname,
					"cx":         cx,
					"cy":         cy,
					"tileSize":   []int{tm.TileWidth, tm.TileHeight},
					"chunkTiles": []int{chW, chH},
					"data":       sub,
				}
				j, _ := json.Marshal(payload)
				hexGz := gzipToHex(j)

				stmt := fmt.Sprintf(
					"REPLACE INTO map_chunk_layer (map_id, layer, cx, cy, rev, payload) VALUES ('%s','%s',%d,%d,%d,UNHEX('%s'));\n",
					escapeSQL(*mapID), escapeSQL(lname), cx, cy, *rev, hexGz,
				)
				fChunk.WriteString(stmt)
				w(stmt)
			}
		}
	}
	w("\n")

	/* -------- 5) map_entity：objectgroup → entities -------- */

	fEntity.WriteString(fmt.Sprintf("-- INSERTs for map_entity (map_id=%s)\n", *mapID))
	for _, layer := range tm.Layers {
		if layer.Type != "objectgroup" {
			continue
		}
		for _, obj := range layer.Objects {
			// properties 聚合为 JSON
			props := map[string]any{}
			for _, p := range obj.Properties {
				var v any
				_ = json.Unmarshal(p.Value, &v)
				props[p.Name] = v
			}
			compJSON, _ := json.Marshal(props)

			// 归属块（按锚点）
			tx := int(obj.X) / tm.TileWidth
			ty := int(obj.Y) / tm.TileHeight
			pcx := tx / chW
			pcy := ty / chH

			otype := obj.Type
			if otype == "" {
				otype = obj.Name
			}
			if otype == "" {
				otype = "object"
			}

			stmt := fmt.Sprintf(
				"INSERT INTO map_entity (map_id, type, x, y, w, h, comp_json, chunk_x, chunk_y) VALUES "+
					"('%s','%s',%d,%d,%d,%d,'%s',%d,%d);\n",
				escapeSQL(*mapID),
				escapeSQL(otype),
				int(obj.X), int(obj.Y), int(obj.Width), int(obj.Height),
				escapeSQL(string(compJSON)),
				pcx, pcy,
			)
			fEntity.WriteString(stmt)
			w(stmt)
		}
	}
	w("\nSET FOREIGN_KEY_CHECKS=1;\n")

	fmt.Printf("OK\nmap_id: %s\nmap tiles: %dx%d (tile %dx%d px)\nchunk: %dx%d -> grid %dx%d\n", *mapID, tm.Width, tm.Height, tm.TileWidth, tm.TileHeight, chW, chH, gridW, gridH)
	fmt.Println("files in", *outDir)
	fmt.Println("  - all.sql")
	fmt.Println("  - map_meta_inserts.sql")
	fmt.Println("  - map_imagelayer_inserts.sql")
	fmt.Println("  - map_layer_meta_inserts.sql")
	fmt.Println("  - map_chunk_layer_inserts.sql")
	fmt.Println("  - map_entity_inserts.sql")
}

/* ------------------- helpers ------------------- */

func parseChunk(s string) (int, int, error) {
	re := regexp.MustCompile(`^\s*(\d+)\s*[xX]\s*(\d+)\s*$`)
	m := re.FindStringSubmatch(s)
	if len(m) != 3 {
		return 0, 0, fmt.Errorf("bad --chunk value: %q", s)
	}
	return atoi(m[1]), atoi(m[2]), nil
}
func atoi(s string) int {
	var n int
	for _, c := range s {
		if c >= '0' && c <= '9' {
			n = n*10 + int(c-'0')
		}
	}
	return n
}
func sanitizeMapID(name string) string {
	re := regexp.MustCompile(`[^a-zA-Z0-9_\-]`)
	id := re.ReplaceAllString(name, "_")
	if len(id) > 64 {
		id = id[:64]
	}
	if id == "" {
		id = "map"
	}
	return id
}

func extractTileChunk(data []int, mapW, mapH, sx, sy, cw, ch int) []int {
	out := make([]int, 0, cw*ch)
	for y := sy; y < min(sy+ch, mapH); y++ {
		start := y*mapW + sx
		end := min(start+cw, y*mapW+mapW)
		row := append([]int(nil), data[start:end]...)
		if len(row) < cw { // 右侧补 0
			row = append(row, make([]int, cw-len(row))...)
		}
		out = append(out, row...)
	}
	rows := min(ch, mapH-sy) // 底部补 0
	if rows < ch {
		out = append(out, make([]int, cw*(ch-rows))...)
	}
	return out
}

func gzipToHex(b []byte) string {
	var buf bytes.Buffer
	gz := gzip.NewWriter(&buf)
	_, _ = gz.Write(b)
	_ = gz.Close()
	return strings.ToUpper(hex.EncodeToString(buf.Bytes()))
}

func escapeSQL(s string) string {
	s = strings.ReplaceAll(s, `\`, `\\`)
	s = strings.ReplaceAll(s, `'`, `''`)
	return s
}
func toMinJSON(v any) string {
	b, _ := json.Marshal(v)
	return string(b)
}
func min(a, b int) int {
	if a < b {
		return a
	}
	return b
}
func must(err error) {
	if err != nil && err != io.EOF {
		panic(err)
	}
}
func mustCreate(p string) *os.File {
	f, err := os.Create(p)
	if err != nil {
		panic(err)
	}
	return f
}

// 简单按名字猜一个 kind（和 ENUM 对应）
func guessKind(l Layer) string {
	n := strings.ToLower(l.Name)
	switch {
	case strings.Contains(n, "land"):
		return "nature"
	case strings.Contains(n, "walk"):
		return "path"
	case strings.Contains(n, "connect"):
		return "path"
	case strings.Contains(n, "deco"):
		return "deco"
	case strings.Contains(n, "home") || strings.Contains(n, "castle") || l.Type == "objectgroup":
		return "business"
	default:
		return "other"
	}
}
